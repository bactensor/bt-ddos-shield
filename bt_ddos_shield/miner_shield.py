import re
import threading
from abc import ABC, abstractmethod
from queue import Queue
from dataclasses import dataclass
from time import sleep

from bt_ddos_shield.address import Address
from bt_ddos_shield.blockchain_manager import AbstractBlockchainManager
from bt_ddos_shield.event_processor import AbstractMinerShieldEventProcessor, MinerShieldEvent
from bt_ddos_shield.address_manager import AbstractAddressManager
from bt_ddos_shield.utils import Hotkey, PublicKey
from bt_ddos_shield.validators_manager import AbstractValidatorsManager
from bt_ddos_shield.manifest_manager import AbstractManifestManager
from bt_ddos_shield.state_manager import AbstractMinerShieldStateManager, MinerShieldState


@dataclass
class MinerShieldOptions:
    """
    A class to represent the configuration options for the MinerShield.
    """

    auto_hide_original_server: bool = False  # If True, the original server will be hidden after some time after shield
                                             # gets enabled. Method hide_original_server in AddressManager will be called.

    auto_hide_delay_sec: int = 600  # Time in seconds after which the original server will be hidden if
                                    # auto_hide_original_server is set to True.

    retry_delay: int = 5  # Time in seconds to wait before retrying failed task.


class MinerShieldException(Exception):
    pass


class MinerShieldDisabledException(MinerShieldException):
    """
    Exception raised when shield is disabled and user want to schedule some action to it.
    """
    pass


class MinerShield:
    """
    Main class to be used by Miner to shield himself from DDoS. Call enable() to start the shield. No methods in
    managers should be called directly. All operations are done by worker thread. After starting shield user can
    schedule tasks to be executed asynchronously.
    """

    def __init__(self, miner_hotkey: Hotkey, validators_manager: AbstractValidatorsManager,
                 address_manager: AbstractAddressManager, manifest_manager: AbstractManifestManager,
                 blockchain_manager: AbstractBlockchainManager, state_manager: AbstractMinerShieldStateManager,
                 event_processor: AbstractMinerShieldEventProcessor, options: MinerShieldOptions):
        """
        Initialize the MinerShield class.

        Args:
            miner_hotkey: Hotkey of shielded miner.
            validators_manager: Instance of AbstractValidatorsManager to manage validators and their keys.
            address_manager: Instance of AbstractAddressManager to manage public IP/domain addresses assigned to validators.
            manifest_manager: Instance of AbstractManifestManager to manage publishing manifest file.
            blockchain_manager: Instance of AbstractBlockchainManager to manage blockchain operations.
            state_manager: Instance of AbstractMinerShieldStateManager to manage state of the shield.
            event_processor: Instance of AbstractEventProcessor to handle events generated by the shield.
            options: Instance of MinerShieldOptions.
        """
        self.miner_hotkey = miner_hotkey
        self.validators_manager = validators_manager
        self.address_manager = address_manager
        self.manifest_manager = manifest_manager
        self.blockchain_manager = blockchain_manager
        self.state_manager = state_manager
        self.event_processor = event_processor
        self.options = options

        self.worker_thread = None
        self.task_queue = Queue()
        self.run = False
        self.finishing = False

    def enable(self):
        """
        Enable shield. It starts worker thread, which will do such steps if run for the first time:
        1. Fetch validators keys.
        2. Creates addresses for all validators.
        3. Save manifest file.
        4. Publish link to manifest file to blockchain.
        5. Eventually close public access to original IP after some time.

        It puts events to event_manager after each finished operation. Current state is managed by state_manager.
        If any error occurs it is retried forever until shield is disabled.

        When shield is running, user can schedule tasks to be processed by worker.
        """
        if self.worker_thread is not None:
            # already started
            return

        self.finishing = False
        self.run = True
        self._add_task(MinerShieldInitializeTask())
        self.worker_thread = threading.Thread(target=self._worker_function)
        self.worker_thread.start()

    def disable(self):
        """
        Disable shield. It stops worker thread after finishing current task. Function blocks until worker is stopped.
        """
        self._add_task(MinerShieldDisableTask())
        self.finishing = True
        self.worker_thread.join()
        self.task_queue = Queue()  # clear task queue
        self.worker_thread = None

    def ban_validator(self, validator_hotkey: Hotkey):
        """
        Ban a validator by its hotkey. Task will be executed by worker. It will update manifest file and publish info
        about new file version to blockchain.
        """
        self._add_task(MinerShieldBanValidatorTask(validator_hotkey))

    def _add_task(self, task: 'AbstractMinerShieldTask'):
        """
        Add task to task queue. It will be handled by _worker_function.
        """
        if not self.run:
            raise MinerShieldDisabledException()

        self.task_queue.put(task)

    def _worker_function(self):
        """
        Function called in separate thread by enable() to start the shield. It is handling events put to task_queue.
        """
        self._event("Starting shield")

        while self.run:
            task: AbstractMinerShieldTask = self.task_queue.get()
            try_count: int = 1

            while self.run:
                self._event("Handling task {task}, try {try_count}", task=task, try_count=try_count)

                try:
                    task.run(self)
                    self._event("Task {task} finished successfully", task=task)
                    break
                except Exception as e:
                    self._event("Error during handling task {task}", e, task=task)

                    if self.finishing:
                        break

                    try_count += 1
                    sleep(self.options.retry_delay)

        self._event("Stopping shield")

    def _handle_initialize(self):
        """
        Initialize shield. Load state and initial validators set.
        """
        self.state_manager.get_state()
        self._event("State loaded")

        self.validators_manager.refresh_validators()
        validators: dict[Hotkey, str] = self.validators_manager.get_validators()
        self._event("Validators loaded, got {validators_count} validators", validators_count=len(validators))

        self._add_task(MinerShieldValidatorsChangedTask())

    def _handle_disable(self):
        self.run = False

    @classmethod
    def _calculate_validators_diff(cls, current_state: MinerShieldState, fetched_validators: dict[Hotkey, PublicKey]):
        """
        Calculates difference between newly fetched validators set and one saved in state and returns validators
        which should be removed, added or updated.
        """
        # remove banned validators from fetched validators
        for banned_validator in current_state.banned_validators.keys():
            fetched_validators.pop(banned_validator, None)

        # calculate difference between current state and fetched validators
        deprecated_validators = current_state.known_validators.keys() - fetched_validators.keys()
        new_validators = fetched_validators.keys() - current_state.known_validators.keys()
        changed_validators = {
            k: fetched_validators[k] for k in fetched_validators.keys() & current_state.known_validators.keys()
                if fetched_validators[k] != current_state.known_validators[k]
        }

        return deprecated_validators, new_validators, changed_validators

    def _handle_deprecated_validators(self, current_state: MinerShieldState, deprecated_validators: set[Hotkey]):
        for validator in deprecated_validators:
            self._event("Removing validator {validator}", validator=validator)

            if validator in current_state.active_addresses:
                self.address_manager.remove_address(current_state.active_addresses[validator])

            self.state_manager.remove_validator(validator)

    def _handle_new_validators(self, fetched_validators: dict[Hotkey, PublicKey], new_validators: set[Hotkey]):
        for validator in new_validators:
            self._event("Adding validator {validator}", validator=validator)

            new_address = self.address_manager.create_address()

            try:
                self.state_manager.add_validator(validator, fetched_validators[validator], new_address)
            except Exception as e:
                self.address_manager.remove_address(new_address.address_id)
                raise e

    def _handle_changed_validators(self, changed_validators: dict[Hotkey, PublicKey]):
        for validator, new_key in changed_validators:
            self._event("Updating validator {validator}", validator=validator)
            self.state_manager.update_validator_public_key(validator, new_key)

    def _handle_validators_changed(self):
        current_state: MinerShieldState = self.state_manager.get_state()
        fetched_validators: dict[Hotkey, PublicKey] = self.validators_manager.get_validators()

        deprecated_validators, new_validators, changed_validators = \
            self._calculate_validators_diff(current_state, fetched_validators)

        self._event(
            "Handling validators change, deprecated_validators count={deprecated_validators_count}"
            ", new_validators count={new_validators_count}, changed_validators count={changed_validators_count}",
            deprecated_validators_count=len(deprecated_validators), new_validators_count=len(new_validators),
            changed_validators_count=len(changed_validators)
        )

        self._handle_deprecated_validators(current_state, deprecated_validators)
        self._handle_new_validators(fetched_validators, new_validators)
        self._handle_changed_validators(changed_validators)

        if deprecated_validators or new_validators or changed_validators:
            # if anything changed update manifest file and publish new version to blockchain
            self._add_task(MinerShieldUpdateManifestTask())

    def _handle_ban_validator(self, validator_hotkey: Hotkey):
        """
        Ban validator by its hotkey. If something changed, MinerShieldValidatorsChangedTask will apply asynchronously
        this change where needed.
        """
        self.state_manager.add_banned_validator(validator_hotkey)
        self._event("Validator {validator_hotkey} added to banned set", validator_hotkey=validator_hotkey)
        self._add_task(MinerShieldValidatorsChangedTask())

    def _handle_update_manifest(self):
        """
        Update manifest file and schedule publishing it to blockchain.
        """
        address = self.manifest_manager.add_mapping_file(self.state_manager.get_state().active_addresses)
        self._event("Manifest updated, new address: {address}", address=address)
        self._add_task(MinerShieldPublishManifestTask(address))

    def _handle_publish_manifest(self, address: Address):
        """
        Publish info about current manifest file to blockchain.
        """
        current_address = self.address_manager.deserialize_address(self.blockchain_manager.get(self.miner_hotkey))
        if current_address != address:
            self.blockchain_manager.put(self.miner_hotkey, address.serialize())
            self._event("Manifest published")

    def _event(self, template: str, exception: Exception = None, **kwargs):
        """
        Add event to event processor.

        Args:
            template: Description template to be filled using kwargs.
            exception: Exception to be attached to event.
            kwargs: Event params. Used also to fill template.
        """
        return self.event_processor.add_event(MinerShieldEvent(template, exception, **kwargs))


class AbstractMinerShieldTask(ABC):
    """
    Task to be executed by shield worker.
    """

    NAME_DELETER = re.compile(r'^MinerShield(.*)Task$')

    @abstractmethod
    def run(self, miner_shield: MinerShield):
        """
        Run task in miner_shield context.
        """
        pass

    def __repr__(self):
        return self.NAME_DELETER.sub(r'\1', self.__class__.__name__)


class MinerShieldInitializeTask(AbstractMinerShieldTask):
    def run(self, miner_shield: MinerShield):
        miner_shield._handle_initialize()


class MinerShieldDisableTask(AbstractMinerShieldTask):
    def run(self, miner_shield: MinerShield):
        miner_shield._handle_disable()


class MinerShieldValidatorsChangedTask(AbstractMinerShieldTask):
    def run(self, miner_shield: MinerShield):
        miner_shield._handle_validators_changed()


class MinerShieldBanValidatorTask(AbstractMinerShieldTask):
    def __init__(self, validator_hotkey: Hotkey):
        self.validator_hotkey = validator_hotkey

    def run(self, miner_shield: MinerShield):
        miner_shield._handle_ban_validator(self.validator_hotkey)


class MinerShieldUpdateManifestTask(AbstractMinerShieldTask):
    def run(self, miner_shield: MinerShield):
        miner_shield._handle_update_manifest()


class MinerShieldPublishManifestTask(AbstractMinerShieldTask):
    def __init__(self, address: Address):
        self.address = address

    def run(self, miner_shield: MinerShield):
        miner_shield._handle_publish_manifest(self.address)
