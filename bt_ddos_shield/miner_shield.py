import re
import threading
from abc import ABC, abstractmethod
from queue import Queue
from dataclasses import dataclass
from time import sleep

from bt_ddos_shield.blockchain_manager import AbstractBlockchainManager
from bt_ddos_shield.event_processor import AbstractMinerShieldEventProcessor, MinerShieldEvent
from bt_ddos_shield.address_manager import AbstractAddressManager
from bt_ddos_shield.utils import Hotkey
from bt_ddos_shield.validators_manager import AbstractValidatorsManager
from bt_ddos_shield.manifest_manager import AbstractManifestManager
from bt_ddos_shield.state_manager import AbstractMinerShieldStateManager


@dataclass
class MinerShieldOptions:
    """
    A class to represent the configuration options for the MinerShield.
    """

    auto_hide_original_server: bool = False # If True, the original server will be hidden after some time after shield
                                            # gets enabled. Method hide_original_server in AddressManager will be called.

    auto_hide_delay_sec: int = 600          # Time in seconds after which the original server will be hidden if
                                            # auto_hide_original_server is set to True.

    retry_delay: int = 5   # Time in seconds to wait before retrying failed task.

    max_retries: int = -1  # Maximum number of retries for failed task. If set to negative value, task will be retried
                           # forever, until eventually shield gets disabled.


class MinerShieldException(Exception):
    pass


class MinerShieldDisabledException(MinerShieldException):
    """
    Exception raised when shield is disabled and user want to schedule some action to it.
    """
    pass


class MinerShield:
    """
    Main class to be used by Miner to shield himself from DDoS. Call enable() to start the shield. No methods in
    managers should be called directly. All operations are done by worker thread. After starting shield user can
    schedule tasks to be executed asynchronously.
    """

    def __init__(self, validators_manager: AbstractValidatorsManager, address_manager: AbstractAddressManager,
                 manifest_manager: AbstractManifestManager, blockchain_manager: AbstractBlockchainManager,
                 state_manager: AbstractMinerShieldStateManager, event_processor: AbstractMinerShieldEventProcessor,
                 options: MinerShieldOptions):
        """
        Initialize the MinerShield class.

        Args:
            validators_manager: Instance of AbstractValidatorsManager to manage validators and their keys.
            address_manager: Instance of AbstractAddressManager to manage public IP/domain addresses assigned to validators.
            manifest_manager: Instance of AbstractManifestManager to manage publishing manifest file.
            blockchain_manager: Instance of AbstractBlockchainManager to manage blockchain operations.
            state_manager: Instance of AbstractMinerShieldStateManager to manage state of the shield.
            event_processor: Instance of AbstractEventProcessor to handle events generated by the shield.
            options: Instance of MinerShieldOptions.
        """
        self.validators_manager = validators_manager
        self.address_manager = address_manager
        self.manifest_manager = manifest_manager
        self.blockchain_manager = blockchain_manager
        self.state_manager = state_manager
        self.event_processor = event_processor
        self.options = options

        self.worker_thread = None
        self.task_queue = Queue()
        self.run = False
        self.finishing = False

    def enable(self):
        """
        Enable shield. It starts worker thread, which will do such steps if run for the first time:
        1. Fetch validators keys.
        2. Creates addresses for all validators.
        3. Save manifest file.
        4. Publish link to manifest file to blockchain.
        5. Eventually close public access to original IP after some time.

        It puts events to event_manager after each finished operation. Current state is managed by state_manager.
        If any error occurs it is retried forever until shield is disabled.

        When shield is running, user can schedule tasks to be processed by worker.
        """
        if self.worker_thread is not None:
            # already started
            return

        self.finishing = False
        self.run = True
        self._add_task(MinerShieldInitializeTask())
        self.worker_thread = threading.Thread(target=self._worker_function)
        self.worker_thread.start()

    def disable(self):
        """
        Disable shield. It stops worker thread after finishing current task. Function blocks until worker is stopped.
        """
        self._add_task(MinerShieldDisableTask())
        self.finishing = True
        self.worker_thread.join()
        self.worker_thread = None
        self.task_queue = Queue() # clear task queue

    def ban_validator(self, validator_hotkey: Hotkey):
        """
        Ban a validator by its hotkey. Task will be executed by worker. It will update manifest file and publish info
        about new file version to blockchain.

        Args:
            validator_hotkey: The hotkey of the validator.
        """
        self._add_task(MinerShieldBanValidatorTask(validator_hotkey))

    def _add_task(self, task: 'AbstractMinerShieldTask'):
        """
        Add task to task queue. It will be handled by _worker_function.
        """
        if not self.run:
            raise MinerShieldDisabledException()

        self.task_queue.put(task)

    def _worker_function(self):
        """
        Function called in separate thread by enable() to start the shield. It is handling events put to task_queue.
        """

        self._event(f"Starting shield")

        while self.run:
            task = self.task_queue.get()
            try_count: int = 1

            while self.run:
                self._event(f"Handling task {task}, try {try_count}")

                try:
                    task.run(self)
                    self._event(f"Task {task} finished successfully")
                    break
                except Exception as e:
                    self._event(f"Error during handling task {task}", e)

                    # for negative max_retries value, retry forever
                    if self.finishing or (0 <= self.options.max_retries < try_count):
                        break

                    try_count += 1
                    sleep(self.options.retry_delay)

        self._event(f"Stopping shield")

    def _handle_initialize(self):
        """
        Initialize shield. Load state and initial validators set.
        """
        self.state_manager.get_state()
        self._event("State loaded")

        self.validators_manager.refresh_validators()
        validators: dict[Hotkey, str] = self.validators_manager.get_validators()
        self._event(f"Validators refreshed, got {len(validators)} validators")

        self._add_task(MinerShieldValidatorsChangedTask())

    def _handle_disable(self):
        self.run = False

    def _handle_validators_changed(self):
        """
        Calculates difference between newly fetched validators set and one saved in state and run logic for any changes.
        """

        # get current state and recently fetched validators
        current_state = self.state_manager.get_state()
        fetched_validators: dict[Hotkey, str] = self.validators_manager.get_validators()

        # remove banned validators from fetched validators
        for banned_validator in current_state.banned_validators.keys():
            fetched_validators.pop(banned_validator, None)

        # calculate difference between current state and fetched validators
        deprecated_validators = current_state.known_validators.keys() - fetched_validators.keys()
        new_validators = fetched_validators.keys() - current_state.known_validators.keys()
        changed_validators = {
            k: fetched_validators[k] for k in fetched_validators.keys() & current_state.known_validators.keys()
                if fetched_validators[k] != current_state.known_validators[k]
        }

        # handle changes in validators

        self._event(
            f"Handling validators change, deprecated_validators count={len(deprecated_validators)}"
            f", new_validators count={len(new_validators)}, changed_validators count={len(changed_validators)}"
        )

        for validator in deprecated_validators:
            self._event(f"Removing validator {validator}")

            if validator in current_state.active_addresses:
                self.address_manager.remove_address(current_state.active_addresses[validator])

            self.state_manager.remove_validator(validator)

        # TODO handle new_validators and changed_validators

        if deprecated_validators or new_validators or changed_validators:
            # if anything changed update manifest file and publish new version to blockchain
            # TODO also check state of shield if manifest was published at all
            pass

    def _handle_ban_validator(self, validator_hotkey: Hotkey):
        """
        Ban validator by its hotkey. It will update manifest file and publish info about new file version to blockchain.
        """
        # TODO
        pass

    def _event(self, description: str, *args, **kwargs):
        """
        Add event to event processor.
        """
        return self.event_processor.add_event(MinerShieldEvent(description, *args, **kwargs))

class AbstractMinerShieldTask(ABC):
    """
    Task to be executed by shield worker.
    """

    NAME_DELETER = re.compile(r'^MinerShield(.*)Task$')

    @abstractmethod
    def run(self, miner_shield: MinerShield):
        """
        Run task in miner_shield context.

        Args
            miner_shield: Instance of MinerShield in which task is executed.
        """
        pass

    def __repr__(self):
        return self.NAME_DELETER.sub(r'\1', self.__class__.__name__)

class MinerShieldInitializeTask(AbstractMinerShieldTask):
    def run(self, miner_shield: MinerShield):
        miner_shield._handle_initialize()

class MinerShieldDisableTask(AbstractMinerShieldTask):
    def run(self, miner_shield: MinerShield):
        miner_shield._handle_disable()

class MinerShieldValidatorsChangedTask(AbstractMinerShieldTask):
    def run(self, miner_shield: MinerShield):
        miner_shield._handle_validators_changed()

class MinerShieldBanValidatorTask(AbstractMinerShieldTask):
    def __init__(self, validator_hotkey: Hotkey):
        self.validator_hotkey = validator_hotkey

    def run(self, miner_shield: MinerShield):
        miner_shield._handle_ban_validator(self.validator_hotkey)
